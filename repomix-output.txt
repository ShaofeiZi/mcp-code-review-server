This file is a merged representation of the entire codebase, combined into a single document by Repomix.

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)

Additional Info:
----------------

================================================================
Directory Structure
================================================================
docs/
  REPOMIX_INTEGRATION.md
src/
  index.ts
  repomix.ts
.gitignore
package.json
README.md
tsconfig.json

================================================================
Files
================================================================

================
File: docs/REPOMIX_INTEGRATION.md
================
# Repomix Integration Checklist
This document outlines the implementation plan for integrating Repomix with our code review MCP server to enable comprehensive codebase analysis.

## Overview

[Repomix](https://github.com/nomic-ai/repomix) is a tool that can flatten an entire codebase into a single text document, making it easier for large language models (LLMs) to analyze and understand the complete codebase structure. Our goal is to use Repomix to prepare codebases for review and pipe the output to an LLM for evaluation.

## Implementation Tasks

### 1. Repomix Installation and Setup

- [x] Install Repomix:
  ```bash
  npm install repomix --save
  ```
  
- [x] Test basic Repomix functionality with a sample repository

### 2. MCP Server Integration

- [x] Create a new tool in our MCP server called `analyze_repo`:
  - [x] Add tool definition in `ListToolsRequestSchema` handler
  - [x] Implement tool handler in `CallToolRequestSchema` handler
  - [x] Add appropriate input schema (repository path, output format, etc.)
- [x] Add functionality to execute Repomix from within the server:
  ```typescript
  function executeRepomix(repoPath: string, options: RepomixOptions): string {
    // Execute repomix command and capture output
    // Format: repomix --style plain ${repoPath} && cat repomix-output.txt
  }
  ```

### 3. Selective Codebase Flattening

- [x] Implement options for selecting portions of a codebase:
  - [x] By directory/file pattern (e.g., `src/components/**/*.tsx`)
  - [x] By file type (e.g., `.js`, `.ts`, `.py`)
  - [x] By git history (e.g., only recently modified files)
  - [x] By custom inclusion/exclusion rules
- [x] Create a configuration schema for these options:
  ```typescript
  interface RepomixOptions {
    includePaths?: string[];
    excludePaths?: string[];
    fileTypes?: string[];
    recentOnly?: boolean;
    outputFormat?: 'plain' | 'markdown' | 'xml';
    // Additional options
  }
  ```

### 4. LLM Integration (Placeholder)

- [x] Design the interface between Repomix output and LLM:
  ```typescript
  async function sendToLLM(repomixOutput: string): Promise<CodeReviewResult> {
    // TODO: Implement actual LLM API call with the flattened codebase
    // Return structured code review results
  }
  ```

- [x] Create prompts for different types of code reviews:
  - [x] Architecture review
  - [x] Security review
  - [x] Performance review
  - [x] Best practices review

### 5. Output Processing

- [x] Parse and structure the LLM's response:
  ```typescript
  interface CodeReviewResult {
    overview: string;
    issues: Array<{
      file: string;
      line?: number;
      severity: 'critical' | 'major' | 'minor' | 'suggestion';
      description: string;
      recommendation?: string;
    }>;
    recommendations: string[];
    score: number;
  }
  ```

- [x] Store results in a format accessible through the MCP server

### 6. UI/UX Considerations

- [x] Design a workflow for initiating repository analysis
- [x] Create progress indicators for long-running analyses
- [x] Develop a way to present the results in a structured, navigable format

## Implementation Details

### Repomix Integration Method

- [x] Bundle Repomix as a direct dependency in the package.json
- [x] Use Repomix programmatically via its JavaScript API instead of CLI
- [x] Handle output file generation and processing

### Repomix Command Format

We've implemented a programmatic approach using the Repomix library:
```typescript
// Convert user options to Repomix CLI options format
const cliOptions = {
  style: options.outputFormat || 'plain',
  include: includePaths.join(','),
  ignore: excludePaths.join(','),
  // Other options...
};

// Execute Repomix using the programmatic API
runCli([repoPath], process.cwd(), cliOptions);
```

### Example System Prompt

```
You are an expert code reviewer with extensive experience in software architecture, performance optimization, security, and best practices. Analyze the provided codebase and provide a comprehensive review that includes:

1. Overall architecture assessment
2. Identified issues with line numbers and severity ratings
3. Security vulnerabilities
4. Performance bottlenecks
5. Code quality and maintainability concerns
6. Specific recommendations for improvement
7. An overall score from 0-10

Format your response as a detailed report with clear sections and actionable feedback.
```

## Future Enhancements

- Integration with version control systems to track changes over time
- Comparative code reviews between different versions
- Custom review templates for different types of projects (web, mobile, etc.)
- Automatic PR comment generation based on reviews
- Integration with existing code quality tools (ESLint, SonarQube, etc.)
- Complete the LLM integration with actual API calls instead of placeholders

## Resources

- [Repomix GitHub Repository](https://github.com/nomic-ai/repomix)
- [Model Context Protocol Documentation](https://modelcontextprotocol.ai)
- [LLM Code Review Best Practices](https://example.com/llm-code-review) (placeholder link)

================
File: src/repomix.ts
================
/**
 * @file Repomix Integration
 * @version 0.1.0
 * 
 * Handles integration with Repomix for flattening codebases to enable comprehensive code reviews.
 */

import * as fs from 'fs';
import * as path from 'path';
import { runCli } from 'repomix';

/**
 * Options for executing Repomix
 */
export interface RepomixOptions {
  includePaths?: string[];
  excludePaths?: string[];
  fileTypes?: string[];
  specificFiles?: string[];  // New option to specify exact files to process
  recentOnly?: boolean;
  outputFormat?: 'plain' | 'markdown' | 'xml';
  maxFiles?: number;
}

/**
 * Result of a code review performed by an LLM
 */
export interface CodeReviewResult {
  overview: string;
  issues: Array<{
    file: string;
    line?: number;
    severity: 'critical' | 'major' | 'minor' | 'suggestion';
    description: string;
    recommendation?: string;
  }>;
  recommendations: string[];
  score: number;
}

/**
 * Execute Repomix to flatten a codebase into a single text document
 * 
 * @param repoPath Path to the repository to analyze
 * @param options Configuration options for Repomix
 * @returns The path to the output file containing the flattened codebase
 */
export function executeRepomix(repoPath: string, options: RepomixOptions = {}): string {
  try {
    console.log(`Analyzing repository at ${repoPath} with Repomix...`);

    // Convert our options to Repomix CLI options format
    const cliOptions: any = {
      style: options.outputFormat || 'plain',
    };

    // Handle specific files if provided
    if (options.specificFiles && options.specificFiles.length > 0) {
      // Create exact path patterns for each file
      // This converts a list of files into exact path patterns Repomix can understand
      const exactFilePatterns = options.specificFiles.map(filePath => {
        // Make sure path is relative to repo
        const relativePath = path.isAbsolute(filePath)
          ? path.relative(repoPath, filePath)
          : filePath;
          
        // Return exact pattern without wildcards
        return relativePath;
      });
      
      // Set as include pattern
      cliOptions.include = exactFilePatterns.join(',');
    } 
    // Otherwise use normal include/exclude paths
    else {
      // Add include/exclude paths if specified
      if (options.includePaths && options.includePaths.length > 0) {
        cliOptions.include = options.includePaths.join(',');
      }
      
      if (options.excludePaths && options.excludePaths.length > 0) {
        cliOptions.ignore = options.excludePaths.join(',');
      }
      
      // Add file types filter if specified
      if (options.fileTypes && options.fileTypes.length > 0) {
        // Repomix doesn't have a direct file type option, so we'll include by pattern
        // Convert file types to include patterns (e.g., ['.js', '.ts'] -> '**/*.js,**/*.ts')
        const fileTypePatterns = options.fileTypes.map(ext => 
          ext.startsWith('.') ? `**/*${ext}` : `**/*.${ext}`
        );
        
        // If we already had include paths, append these patterns, otherwise set them
        if (cliOptions.include) {
          cliOptions.include += ',' + fileTypePatterns.join(',');
        } else {
          cliOptions.include = fileTypePatterns.join(',');
        }
      }
    }
    
    // Other options
    if (options.recentOnly) {
      cliOptions.gitSortByChanges = true;
    }
    
    // Ensure the output will be written to a file
    cliOptions.output = 'repomix-output.txt';
    
    // Execute Repomix using the programmatic API
    // The runCli function takes (directories, cwd, options)
    runCli([repoPath], process.cwd(), cliOptions)
      .catch(err => {
        console.error('Error running Repomix:', err);
      });
    
    // The output file path
    const outputFilePath = path.join(process.cwd(), 'repomix-output.txt');
    
    // Wait a moment to ensure the file is written
    let attempts = 0;
    const maxAttempts = 10;
    while (!fs.existsSync(outputFilePath) && attempts < maxAttempts) {
      // Simple non-blocking wait
      const startTime = Date.now();
      while (Date.now() - startTime < 500) {
        // Busy wait
      }
      attempts++;
    }
    
    // Check if the file exists
    if (fs.existsSync(outputFilePath)) {
      return outputFilePath;
    } else {
      throw new Error('Repomix did not generate an output file after multiple attempts');
    }
  } catch (error) {
    console.error('Error executing Repomix:', error);
    throw new Error(`Failed to execute Repomix: ${error}`);
  }
}

/**
 * Send the Repomix output to an LLM for code review
 * This is a placeholder implementation that will be completed later
 * 
 * @param repomixOutputPath Path to the Repomix output file
 * @param systemPrompt The system prompt for the LLM
 * @param userPrompt The user prompt for the LLM
 * @returns A promise that resolves to the code review result
 */
export async function sendToLLM(
  repomixOutputPath: string, 
  systemPrompt: string = DEFAULT_SYSTEM_PROMPT,
  userPrompt: string = DEFAULT_USER_PROMPT
): Promise<CodeReviewResult> {
  try {
    // Read the Repomix output file
    const codebaseContent = fs.readFileSync(repomixOutputPath, 'utf-8');
    console.log(`Read ${codebaseContent.length} characters from Repomix output`);
    
    // For now, return a placeholder result
    // TODO: Implement actual LLM API call
    return {
      overview: "Placeholder for LLM code review",
      issues: [{
        file: "example.ts",
        line: 1,
        severity: "suggestion",
        description: "This is a placeholder issue",
        recommendation: "This is a placeholder recommendation"
      }],
      recommendations: ["This is a placeholder recommendation"],
      score: 5
    };
  } catch (error) {
    console.error('Error sending to LLM:', error);
    throw new Error(`Failed to get LLM code review: ${error}`);
  }
}

/**
 * Default system prompt for code review
 */
export const DEFAULT_SYSTEM_PROMPT = `
You are an expert code reviewer with extensive experience in software architecture, performance optimization, security, and best practices. Analyze the provided codebase and provide a comprehensive review that includes:

1. Overall architecture assessment
2. Identified issues with line numbers and severity ratings
3. Security vulnerabilities
4. Performance bottlenecks
5. Code quality and maintainability concerns
6. Specific recommendations for improvement
7. An overall score from 0-10

Format your response as a detailed report with clear sections and actionable feedback.
`;

/**
 * Default user prompt for code review
 */
export const DEFAULT_USER_PROMPT = `
Please review the code provided and give detailed feedback.
`;

/**
 * Analyzes a repository using Repomix and returns a code review
 * 
 * @param repoPath Path to the repository to analyze
 * @param options Options for Repomix execution
 * @param systemPrompt Custom system prompt for the LLM
 * @param userPrompt Custom user prompt for the LLM
 * @returns A promise that resolves to the code review result
 */
export async function analyzeRepo(
  repoPath: string,
  options: RepomixOptions = {},
  systemPrompt?: string,
  userPrompt?: string
): Promise<CodeReviewResult> {
  // Execute Repomix to get the flattened codebase
  const repomixOutputPath = executeRepomix(repoPath, options);
  
  // Send the flattened codebase to an LLM for analysis
  const result = await sendToLLM(
    repomixOutputPath, 
    systemPrompt || DEFAULT_SYSTEM_PROMPT,
    userPrompt || DEFAULT_USER_PROMPT
  );
  
  return result;
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES2022",
    "module": "Node16",
    "moduleResolution": "Node16",
    "outDir": "./build",
    "rootDir": "./src",
    "strict": true,
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}

================
File: package.json
================
{
  "name": "code-review-server",
  "version": "0.1.0",
  "description": "A custom MCP server to perform code reviews",
  "private": true,
  "type": "module",
  "bin": {
    "code-review-server": "./build/index.js"
  },
  "files": [
    "build"
  ],
  "scripts": {
    "build": "tsc && node -e \"require('fs').chmodSync('build/index.js', '755')\"",
    "prepare": "npm run build",
    "watch": "tsc --watch",
    "inspector": "npx @modelcontextprotocol/inspector build/index.js"
  },
  "dependencies": {
    "repomix": "^0.3.0"
  },
  "devDependencies": {
    "@modelcontextprotocol/sdk": "^1.7.0",
    "@types/node": "^20.11.24",
    "bun-types": "^1.2.5",
    "typescript": "^5.3.3"
  }
}

================
File: README.md
================
# Code Review MCP Server

This is a Model Context Protocol (MCP) server that enables AI assistants to perform code reviews.

## Features

- **Code File Scanning**: Automatically scans directory structures to discover code files
- **Multiple Review Types**: Supports security, performance, best practices, and comprehensive code reviews
- **Detailed Analysis**: Provides line-by-line issues with severity ratings and explanations
- **Summary Reports**: Generates overall summaries and quality scores for reviewed code

## Installation

```bash
# Install dependencies
npm install

# Build the server
npm run build

# Optional: make available globally
npm link
```

## Usage

### Using with Claude.app

This server is designed to work with Claude.app. When you created the server, it was automatically registered with Claude.app if you chose that option.

### Using with Inspector

For testing and debugging, you can use the MCP Inspector:

```bash
npm run inspector
```

## Server Capabilities

### Resources

The server exposes code files as resources with the `code://` URI scheme.

### Tools

The server provides the following tools:

- `review_code`: Create a detailed code review for a specific file
- `scan_repo`: Scan a repository directory for code files

### Prompts

The server offers several specialized code review prompts:

- `security_review`: Review code for security vulnerabilities
- `performance_review`: Review code for performance issues
- `best_practices_review`: Review code for adherence to best practices
- `comprehensive_review`: Perform a comprehensive code review

## How It Works

1. When started, the server scans the current directory for code files
2. Files are exposed as resources with appropriate MIME types
3. Code review prompts present the relevant files to the AI
4. The AI analyzes the code and uses the `review_code` tool to submit reviews
5. Reviews include line-specific issues, severity ratings, and overall scores

## Development

To modify or extend this server:

1. Update the source code in `src/index.ts`
2. Rebuild with `npm run build`
3. Test changes with `npm run inspector`

## License

MIT

================
File: src/index.ts
================
#!/usr/bin/env node

/**
 * MCP server that implements a code review system.
 * It allows:
 * - Listing code files as resources
 * - Reading individual code files
 * - Performing code reviews via a tool
 * - Providing code review templates via prompts
 * - Analyzing repositories using Repomix
 */

import { Server } from "@modelcontextprotocol/sdk/server/index.js";
import { StdioServerTransport } from "@modelcontextprotocol/sdk/server/stdio.js";
import {
  CallToolRequestSchema,
  ListResourcesRequestSchema,
  ListToolsRequestSchema,
  ReadResourceRequestSchema,
  ListPromptsRequestSchema,
  GetPromptRequestSchema,
} from "@modelcontextprotocol/sdk/types.js";
import * as fs from 'fs';
import * as path from 'path';
import { execSync } from 'child_process';
import { 
  RepomixOptions, 
  CodeReviewResult, 
  executeRepomix, 
  sendToLLM, 
  analyzeRepo,
  DEFAULT_SYSTEM_PROMPT 
} from './repomix.js';

/**
 * Type alias for a code file.
 */
type CodeFile = { 
  path: string, 
  content: string,
  language: string
};

/**
 * Type alias for a code review.
 */
type CodeReview = {
  filePath: string,
  issues: Array<{
    line: number,
    severity: 'critical' | 'major' | 'minor' | 'suggestion',
    message: string
  }>,
  summary: string,
  score: number
};

/**
 * In-memory storage for code files and reviews.
 * In a real implementation, this would likely be backed by a database.
 */
const codeFiles: { [id: string]: CodeFile } = {};
const codeReviews: { [id: string]: CodeReview } = {};

/**
 * Helper function to get the programming language from a file extension
 */
function getLanguageFromFilePath(filePath: string): string {
  const extension = path.extname(filePath).toLowerCase();
  const extensionMap: {[key: string]: string} = {
    '.js': 'javascript',
    '.ts': 'typescript',
    '.jsx': 'javascript',
    '.tsx': 'typescript',
    '.py': 'python',
    '.rb': 'ruby',
    '.java': 'java',
    '.go': 'go',
    '.php': 'php',
    '.c': 'c',
    '.cpp': 'cpp',
    '.cs': 'csharp',
    '.html': 'html',
    '.css': 'css',
    '.rs': 'rust',
    '.swift': 'swift',
    '.kt': 'kotlin',
    '.scala': 'scala',
    '.sh': 'bash',
    '.md': 'markdown',
    '.json': 'json',
    '.yml': 'yaml',
    '.yaml': 'yaml',
    '.xml': 'xml',
    '.sql': 'sql',
  };
  
  return extensionMap[extension] || 'plaintext';
}

/**
 * Helper function to get the MIME type from a file extension
 */
function getMimeTypeFromFilePath(filePath: string): string {
  const extension = path.extname(filePath).toLowerCase();
  const mimeMap: {[key: string]: string} = {
    '.js': 'application/javascript',
    '.ts': 'application/typescript',
    '.jsx': 'application/javascript',
    '.tsx': 'application/typescript',
    '.py': 'text/x-python',
    '.rb': 'text/x-ruby',
    '.java': 'text/x-java',
    '.go': 'text/x-go',
    '.php': 'application/x-php',
    '.c': 'text/x-c',
    '.cpp': 'text/x-c++',
    '.cs': 'text/x-csharp',
    '.html': 'text/html',
    '.css': 'text/css',
    '.rs': 'text/x-rust',
    '.swift': 'text/x-swift',
    '.kt': 'text/x-kotlin',
    '.scala': 'text/x-scala',
    '.sh': 'text/x-shellscript',
    '.md': 'text/markdown',
    '.json': 'application/json',
    '.yml': 'application/x-yaml',
    '.yaml': 'application/x-yaml',
    '.xml': 'application/xml',
    '.sql': 'application/sql',
  };
  
  return mimeMap[extension] || 'text/plain';
}

/**
 * Helper function to scan a directory for code files
 */
function scanDirectory(dir: string, baseDir: string = ''): void {
  try {
    const files = fs.readdirSync(dir);
    
    for (const file of files) {
      const fullPath = path.join(dir, file);
      const relativePath = path.join(baseDir, file);
      
      if (fs.statSync(fullPath).isDirectory()) {
        // Skip node_modules and hidden directories
        if (file !== 'node_modules' && !file.startsWith('.')) {
          scanDirectory(fullPath, relativePath);
        }
      } else {
        // Only add files with recognized extensions
        const extension = path.extname(file);
        if (extension && !file.startsWith('.')) {
          try {
            const content = fs.readFileSync(fullPath, 'utf-8');
            const language = getLanguageFromFilePath(fullPath);
            const id = Buffer.from(relativePath).toString('base64');
            
            codeFiles[id] = {
              path: relativePath,
              content,
              language
            };
          } catch (error) {
            console.error(`Error reading file ${fullPath}:`, error);
          }
        }
      }
    }
  } catch (error) {
    console.error(`Error scanning directory ${dir}:`, error);
  }
}

/**
 * Create an MCP server with capabilities for resources (to list/read code files),
 * tools (to create code reviews), and prompts (for review templates).
 */
const server = new Server(
  {
    name: "code review-server",
    version: "0.1.0",
  },
  {
    capabilities: {
      resources: {},
      tools: {},
      prompts: {},
    },
  }
);

/**
 * Handler for listing available code files as resources.
 * Each file is exposed as a resource with:
 * - A code:// URI scheme
 * - Appropriate MIME type based on file extension
 * - Human readable name and description
 */
server.setRequestHandler(ListResourcesRequestSchema, async () => {
  // Scan the current directory if no files have been loaded yet
  if (Object.keys(codeFiles).length === 0) {
    const workingDir = process.cwd();
    scanDirectory(workingDir);
  }
  
  return {
    resources: Object.entries(codeFiles).map(([id, file]) => ({
      uri: `code:///${id}`,
      mimeType: getMimeTypeFromFilePath(file.path),
      name: file.path,
      description: `A ${file.language} file: ${file.path}`
    }))
  };
});

/**
 * Handler for reading the contents of a specific code file.
 * Takes a code:// URI and returns the file content with appropriate MIME type.
 */
server.setRequestHandler(ReadResourceRequestSchema, async (request) => {
  const url = new URL(request.params.uri);
  const id = url.pathname.replace(/^\//, '');
  const file = codeFiles[id];

  if (!file) {
    throw new Error(`File ${id} not found`);
  }

  return {
    contents: [{
      uri: request.params.uri,
      mimeType: getMimeTypeFromFilePath(file.path),
      text: file.content
    }]
  };
});

/**
 * Handler that lists available tools.
 * Exposes tools for code review and repository analysis.
 */
server.setRequestHandler(ListToolsRequestSchema, async () => {
  return {
    tools: [
      {
        name: "review_code",
        description: "Create a code review for a specific file",
        inputSchema: {
          type: "object",
          properties: {
            filePath: {
              type: "string",
              description: "Path to the file to review"
            },
            issues: {
              type: "array",
              description: "List of issues found in the code",
              items: {
                type: "object",
                properties: {
                  line: {
                    type: "number",
                    description: "Line number where the issue is found"
                  },
                  severity: {
                    type: "string",
                    enum: ["critical", "major", "minor", "suggestion"],
                    description: "Severity of the issue"
                  },
                  message: {
                    type: "string",
                    description: "Description of the issue"
                  }
                },
                required: ["line", "severity", "message"]
              }
            },
            summary: {
              type: "string",
              description: "Overall summary of the code review"
            },
            score: {
              type: "number",
              description: "Score of the code quality (0-10)"
            }
          },
          required: ["filePath", "issues", "summary", "score"]
        }
      },
      {
        name: "scan_repo",
        description: "Scan a repository directory for code files",
        inputSchema: {
          type: "object",
          properties: {
            directory: {
              type: "string",
              description: "Directory path to scan (defaults to current directory)"
            }
          }
        }
      },
      {
        name: "analyze_repo",
        description: "Analyze a repository using Repomix and provide a comprehensive code review",
        inputSchema: {
          type: "object",
          properties: {
            repoPath: {
              type: "string",
              description: "Path to the repository to analyze (defaults to current directory)"
            },
            includePaths: {
              type: "array",
              items: { type: "string" },
              description: "List of paths to include in the analysis (e.g., 'src/components/**/*.tsx')"
            },
            excludePaths: {
              type: "array",
              items: { type: "string" },
              description: "List of paths to exclude from the analysis (e.g., 'node_modules/**')"
            },
            specificFiles: {
              type: "array",
              items: { type: "string" },
              description: "List of specific files to analyze (takes precedence over includePaths and fileTypes)"
            },
            fileTypes: {
              type: "array",
              items: { type: "string" },
              description: "List of file types to include (e.g., '.js', '.ts', '.py')"
            },
            recentOnly: {
              type: "boolean",
              description: "Whether to only analyze recently modified files"
            },
            outputFormat: {
              type: "string",
              enum: ["plain", "markdown", "xml"],
              description: "Format of the Repomix output"
            },
            maxFiles: {
              type: "number",
              description: "Maximum number of files to include in the analysis"
            },
            systemPrompt: {
              type: "string",
              description: "Custom system prompt for the LLM"
            },
            userPrompt: {
              type: "string",
              description: "Custom user prompt for the LLM"
            }
          },
          required: ["repoPath"]
        }
      }
    ]
  };
});

/**
 * Handler for the tools.
 */
server.setRequestHandler(CallToolRequestSchema, async (request) => {
  switch (request.params.name) {
    case "review_code": {
      const filePath = String(request.params.arguments?.filePath);
      const issues = request.params.arguments?.issues as Array<{line: number, severity: string, message: string}>;
      const summary = String(request.params.arguments?.summary);
      const score = Number(request.params.arguments?.score);
      
      if (!filePath || !issues || !summary || isNaN(score)) {
        throw new Error("All fields are required for a code review");
      }

      const id = Buffer.from(filePath).toString('base64');
      codeReviews[id] = {
        filePath,
        issues: issues.map(issue => ({
          line: issue.line,
          severity: issue.severity as 'critical' | 'major' | 'minor' | 'suggestion',
          message: issue.message
        })),
        summary,
        score
      };

      return {
        content: [{
          type: "text",
          text: `Created code review for ${filePath} with score ${score}/10`
        }]
      };
    }
    
    case "scan_repo": {
      const directory = String(request.params.arguments?.directory || process.cwd());
      
      try {
        // Clear existing code files
        Object.keys(codeFiles).forEach(key => delete codeFiles[key]);
        
        // Scan the directory
        scanDirectory(directory);
        
        return {
          content: [{
            type: "text",
            text: `Scanned ${directory} and found ${Object.keys(codeFiles).length} code files`
          }]
        };
      } catch (error) {
        throw new Error(`Failed to scan directory: ${error}`);
      }
    }

    case "analyze_repo": {
      const repoPath = String(request.params.arguments?.repoPath || process.cwd());
      
      // Extract options from the request
      const options: RepomixOptions = {
        includePaths: request.params.arguments?.includePaths as string[],
        excludePaths: request.params.arguments?.excludePaths as string[],
        specificFiles: request.params.arguments?.specificFiles as string[],
        fileTypes: request.params.arguments?.fileTypes as string[],
        recentOnly: Boolean(request.params.arguments?.recentOnly),
        outputFormat: request.params.arguments?.outputFormat as 'plain' | 'markdown' | 'xml',
        maxFiles: Number(request.params.arguments?.maxFiles) || undefined
      };
      
      const systemPrompt = request.params.arguments?.systemPrompt as string;
      const userPrompt = request.params.arguments?.userPrompt as string;
      
      try {
        // Display a progress message
        const progressContent = {
          type: "text",
          text: `Analyzing repository at ${repoPath}... This may take a moment.`
        };
        
        // Actually perform the analysis (async)
        analyzeRepo(repoPath, options, systemPrompt, userPrompt)
          .then(result => {
            // Store the review result for possible future access
            const id = Buffer.from(`repo:${repoPath}`).toString('base64');
            codeReviews[id] = {
              filePath: repoPath,
              issues: result.issues.map(issue => ({
                line: issue.line || 0,
                severity: issue.severity,
                message: issue.description
              })),
              summary: result.overview,
              score: result.score
            };
          })
          .catch(error => {
            console.error("Error in background analysis:", error);
          });
        
        // Return immediately with the progress message
        return {
          content: [progressContent]
        };
      } catch (error) {
        throw new Error(`Failed to analyze repository: ${error}`);
      }
    }

    default:
      throw new Error("Unknown tool");
  }
});

/**
 * Handler that lists available prompts.
 * Exposes prompts for different types of code reviews.
 */
server.setRequestHandler(ListPromptsRequestSchema, async () => {
  return {
    prompts: [
      {
        name: "security_review",
        description: "Review code for security vulnerabilities",
      },
      {
        name: "performance_review",
        description: "Review code for performance issues",
      },
      {
        name: "best_practices_review",
        description: "Review code for adherence to best practices",
      },
      {
        name: "comprehensive_review",
        description: "Perform a comprehensive code review",
      },
      {
        name: "repository_analysis",
        description: "Analyze an entire repository using Repomix"
      }
    ]
  };
});

/**
 * Handler for the code review prompts.
 * Returns a prompt that requests a specific type of code review for a file or an entire repository.
 */
server.setRequestHandler(GetPromptRequestSchema, async (request) => {
  // Scan the directory if not already done
  if (Object.keys(codeFiles).length === 0) {
    const workingDir = process.cwd();
    scanDirectory(workingDir);
  }
  
  let promptInstructions = "";
  
  switch (request.params.name) {
    case "security_review":
      promptInstructions = "Please perform a security code review of the following code. Focus on identifying security vulnerabilities such as injection attacks, authentication issues, authorization problems, data exposure, XSS, CSRF, and other security concerns. For each issue, provide the line number, severity (critical, major, minor), and a detailed explanation with a suggested fix.";
      break;
    case "performance_review":
      promptInstructions = "Please perform a performance review of the following code. Focus on identifying performance bottlenecks, inefficient algorithms, unnecessary computations, memory leaks, and other performance issues. For each issue, provide the line number, severity (critical, major, minor), and a detailed explanation with a suggested optimization.";
      break;
    case "best_practices_review":
      promptInstructions = "Please review the following code for adherence to best practices. Focus on code style, naming conventions, documentation, modularity, error handling, and other programming best practices. For each issue, provide the line number, severity (critical, major, minor), and a detailed explanation with a suggested improvement.";
      break;
    case "comprehensive_review":
      promptInstructions = "Please perform a comprehensive code review of the following code. Consider security vulnerabilities, performance issues, adherence to best practices, code style, maintainability, and overall code quality. For each issue, provide the line number, severity (critical, major, minor), and a detailed explanation with a suggested improvement.";
      break;
    case "repository_analysis":
      promptInstructions = "Please analyze the following repository using Repomix. Provide a comprehensive code review including architecture assessment, identified issues, security vulnerabilities, performance bottlenecks, code quality concerns, and specific recommendations for improvement.";
      
      return {
        messages: [
          {
            role: "user",
            content: {
              type: "text",
              text: promptInstructions
            }
          },
          {
            role: "user",
            content: {
              type: "text",
              text: "To analyze the repository, use the analyze_repo tool with the appropriate options. Provide a detailed review with specific issues, their severity ratings, and an overall code quality score from 0-10 for the repository."
            }
          }
        ]
      };
    default:
      throw new Error("Unknown prompt");
  }
  
  // Get a list of file resources to present to the user
  const fileResources = Object.entries(codeFiles).map(([id, file]) => ({
    type: "resource" as const,
    resource: {
      uri: `code:///${id}`,
      mimeType: getMimeTypeFromFilePath(file.path),
      text: file.content
    }
  }));
  
  // If there are too many files, limit to the first 10
  const limitedResources = fileResources.length > 10 ? fileResources.slice(0, 10) : fileResources;
  
  return {
    messages: [
      {
        role: "user",
        content: {
          type: "text",
          text: promptInstructions
        }
      },
      ...limitedResources.map(resource => ({
        role: "user" as const,
        content: resource
      })),
      {
        role: "user",
        content: {
          type: "text",
          text: "For each file, provide a detailed code review with specific issues, their line numbers, and a severity rating. Summarize your findings and give an overall code quality score from 0-10 for each file. Use the review_code tool to submit your formal review for each file when you're done."
        }
      }
    ]
  };
});

/**
 * Start the server using stdio transport.
 * This allows the server to communicate via standard input/output streams.
 */
async function main() {
  const transport = new StdioServerTransport();
  await server.connect(transport);
}

main().catch((error) => {
  console.error("Server error:", error);
  process.exit(1);
});

================
File: .gitignore
================
node_modules/
build/
*.log
.env*



================================================================
End of Codebase
================================================================
